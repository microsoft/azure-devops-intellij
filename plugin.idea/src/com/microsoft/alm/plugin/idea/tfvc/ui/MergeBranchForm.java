// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See License.txt in the project root.

/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.microsoft.alm.plugin.idea.tfvc.ui;

import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.application.ModalityState;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.Messages;
import com.intellij.openapi.ui.TextFieldWithBrowseButton;
import com.intellij.uiDesigner.core.GridConstraints;
import com.intellij.uiDesigner.core.GridLayoutManager;
import com.intellij.util.EventDispatcher;
import com.microsoft.alm.plugin.context.ServerContext;

import javax.swing.BorderFactory;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import java.awt.CardLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.util.EventListener;
import java.util.List;
import java.util.ResourceBundle;

public class MergeBranchForm {

    {
// GUI initializer generated by IntelliJ IDEA GUI Designer
// >>> IMPORTANT!! <<<
// DO NOT EDIT OR ADD ANY CODE HERE!
        $$$setupUI$$$();
    }

    /**
     * Method generated by IntelliJ IDEA GUI Designer
     * >>> IMPORTANT!! <<<
     * DO NOT edit this method OR call it in your code!
     *
     * @noinspection ALL
     */
    private void $$$setupUI$$$() {
        contentPanel = new JPanel();
        contentPanel.setLayout(new GridLayoutManager(3, 2, new Insets(0, 0, 0, 0), -1, -1));
        sourceBranchLabel = new JLabel();
        this.$$$loadLabelText$$$(sourceBranchLabel, ResourceBundle.getBundle("com/microsoft/alm/plugin/idea/ui/tfplugin").getString("MergeBranchDialog.Source"));
        contentPanel.add(sourceBranchLabel, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        sourceText = new TextFieldWithBrowseButton.NoPathCompletion();
        contentPanel.add(sourceText, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        final JLabel label1 = new JLabel();
        label1.setEnabled(true);
        this.$$$loadLabelText$$$(label1, ResourceBundle.getBundle("com/microsoft/alm/plugin/idea/ui/tfplugin").getString("MergeBranchDialog.Target"));
        contentPanel.add(label1, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        targetCombo = new JComboBox();
        contentPanel.add(targetCombo, new GridConstraints(1, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        changesToMergePanel = new JPanel();
        changesToMergePanel.setLayout(new GridLayoutManager(2, 1, new Insets(0, 0, 0, 0), -1, -1));
        contentPanel.add(changesToMergePanel, new GridConstraints(2, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
        changesToMergePanel.setBorder(BorderFactory.createTitledBorder(ResourceBundle.getBundle("com/microsoft/alm/plugin/idea/ui/tfplugin").getString("MergeBranchDialog.ChangesToMerge")));
        changesTypeCombo = new JComboBox();
        changesToMergePanel.add(changesTypeCombo, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        changesetsPanel = new JPanel();
        changesetsPanel.setLayout(new CardLayout(0, 0));
        changesToMergePanel.add(changesetsPanel, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
        label1.setLabelFor(targetCombo);
    }

    /**
     * @noinspection ALL
     */
    private void $$$loadLabelText$$$(JLabel component, String text) {
        StringBuffer result = new StringBuffer();
        boolean haveMnemonic = false;
        char mnemonic = '\0';
        int mnemonicIndex = -1;
        for (int i = 0; i < text.length(); i++) {
            if (text.charAt(i) == '&') {
                i++;
                if (i == text.length()) break;
                if (!haveMnemonic && text.charAt(i) != '&') {
                    haveMnemonic = true;
                    mnemonic = text.charAt(i);
                    mnemonicIndex = result.length();
                }
            }
            result.append(text.charAt(i));
        }
        component.setText(result.toString());
        if (haveMnemonic) {
            component.setDisplayedMnemonic(mnemonic);
            component.setDisplayedMnemonicIndex(mnemonicIndex);
        }
    }

    /**
     * @noinspection ALL
     */
    public JComponent $$$getRootComponent$$$() {
        return contentPanel;
    }

    public interface Listener extends EventListener {
        void stateChanged(boolean canFinish);
    }

    private enum ChangesType {
        ALL {
            public String toString() {
                return "All changes up to a specific version";
            }
        },

        SELECTED {
            public String toString() {
                return "Selected changesets";
            }
        }
    }

    private TextFieldWithBrowseButton.NoPathCompletion sourceText;
    private JComboBox targetCombo;
    private JComboBox changesTypeCombo;
    private JPanel contentPanel;
    private JPanel changesetsPanel;
    private JLabel sourceBranchLabel;
    private JPanel changesToMergePanel;
    private final Project project;
    private final ServerContext serverContext;
    //private final SelectRevisionForm mySelectRevisionForm;
    //private final JTable myChangesetsTable;
    //private final ChangesetsTableModel myChangesetsTableModel;
    private final String dialogTitle;
    private final EventDispatcher<Listener> myEventDispatcher = EventDispatcher.create(Listener.class);
    private boolean mySourceIsDirectory;
    private final FocusListener mySourceFieldFocusListener;
    private final MergeBranchDialog.BranchListProvider branchListProvider;

    public MergeBranchForm(final Project project,
                           final ServerContext serverContext,
                           String initialSourcePath,
                           boolean initialSourcePathIsDirectory,
                           final String dialogTitle,
                           final MergeBranchDialog.BranchListProvider branchListProvider) {
        this.project = project;
        this.serverContext = serverContext;
        this.dialogTitle = dialogTitle;
        this.branchListProvider = branchListProvider;

        sourceBranchLabel.setLabelFor(sourceText.getChildComponent());

        //myChangesetsTableModel = new ChangesetsTableModel();
        //myChangesetsTable = new JBTable(myChangesetsTableModel);
        //myChangesetsTable.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);
        //for (int i = 0; i < ChangesetsTableModel.Column.values().length; i++) {
        //  myChangesetsTable.getColumnModel().getColumn(i).setPreferredWidth(ChangesetsTableModel.Column.values()[i].getWidth());
        //}

        //mySelectRevisionForm = new SelectRevisionForm();

        //changesetsPanel.add(mySelectRevisionForm.getPanel(), ChangesType.ALL.toString());
        //changesetsPanel.add(ScrollPaneFactory.createScrollPane(myChangesetsTable), ChangesType.SELECTED.toString());

        sourceText.setText(initialSourcePath);
        mySourceIsDirectory = initialSourcePathIsDirectory;

        //TODO enable button and allow dynamic lookup of server paths
        sourceText.setButtonEnabled(false);
        //sourceText.getButton().addActionListener(new ActionListener() {
        //    public void actionPerformed(final ActionEvent e) {
        //        ServerBrowserDialog d =
        //          new ServerBrowserDialog(TFSBundle.message("choose.source.item.dialog.title"), project, workspace.getServer(),
        //                                  sourceText.getText(), false, false);
        //        if (d.showAndGet()) {
        //          final TfsTreeForm.SelectedItem selectedItem = d.getSelectedItem();
        //          sourceText.setText(selectedItem != null ? selectedItem.path : null);
        //          mySourceIsDirectory = selectedItem == null || selectedItem.isDirectory;
        //        }
        //        updateOnSourceChange();
        //    }
        //});

        mySourceFieldFocusListener = new FocusAdapter() {
            public void focusLost(final FocusEvent e) {
                mySourceIsDirectory = true;

                // TODO (JETBRAINS) don't do it on focus out, rather provide a 'Refresh' button
                ApplicationManager.getApplication().invokeLater(new Runnable() {
                    @Override
                    public void run() {
                        updateOnSourceChange();
                    }
                }, ModalityState.current());
            }
        };
        sourceText.getTextField().addFocusListener(mySourceFieldFocusListener);

        targetCombo.setModel(new DefaultComboBoxModel());
//    targetCombo.setRenderer(new DefaultListCellRenderer() {
//      public Component getListCellRendererComponent(final JList list,
//                                                    final Object value,
//                                                    final int index,
//                                                    final boolean isSelected,
//                                                    final boolean cellHasFocus) {
//        final Component c = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
//        if (value != null) {
//          Item item = (Item)value;
//          setText(item.getItem());
//        }
//        return c;
//      }
//    });

        targetCombo.addActionListener(new ActionListener() {
            public void actionPerformed(final ActionEvent e) {
                if (changesTypeCombo.getSelectedItem() == ChangesType.SELECTED) {
                    updateChangesetsTable();
                }
            }
        });

        changesTypeCombo.setModel(new DefaultComboBoxModel(ChangesType.values()));

        changesTypeCombo.addActionListener(new ActionListener() {
            public void actionPerformed(final ActionEvent e) {
                if (changesTypeCombo.getSelectedItem() == ChangesType.SELECTED) {
                    updateChangesetsTable();
                }
                ((CardLayout) changesetsPanel.getLayout()).show(changesetsPanel, changesTypeCombo.getSelectedItem().toString());
                fireStateChanged();
            }
        });

        //myChangesetsTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {
        //  public void valueChanged(final ListSelectionEvent e) {
        //    fireStateChanged();
        //  }
        //});

        //changesTypeCombo.setSelectedIndex(0);
        //mySelectRevisionForm.init(project, workspace, initialSourcePath, initialSourcePathIsDirectory);
        changesTypeCombo.setVisible(false);
        changesToMergePanel.setVisible(false);

        // Preinitialize the combo with the branches
        updateOnSourceChange();
        this.targetCombo.setSelectedItem(null);
    }

    public JComponent getContentPanel() {
        return contentPanel;
    }

    private void updateChangesetsTable() {
//    List<Changeset> changesets = new ArrayList<Changeset>();
//    if (targetCombo.getSelectedIndex() != -1) {
//      try {
//        final Collection<MergeCandidate> mergeCandidates = myWorkspace.getServer().getVCS()
//          .queryMergeCandidates(myWorkspace.getName(), myWorkspace.getOwnerName(), sourceText.getText(), getTargetPath(), project,
//                                TFSBundle.message("loading.branches"));
//        for (MergeCandidate candidate : mergeCandidates) {
//          changesets.add(candidate.getChangeset());
//        }
//      }
//      catch (TfsException e) {
//        Messages.showErrorDialog(project, e.getMessage(), dialogTitle);
//      }
//    }
//    myChangesetsTableModel.setChangesets(changesets);
    }

    public String getSourcePath() {
        return sourceText.getText();
    }

    public String getTargetPath() {
        final String targetBranch = (String) targetCombo.getSelectedItem();
        return targetBranch;
    }

//  @Nullable
//  public VersionSpecBase getFromVersion() {
//    ChangesType changesType = (ChangesType)changesTypeCombo.getSelectedItem();
//    if (changesType == ChangesType.SELECTED) {
//      final Changeset fromChangeset =
//        myChangesetsTableModel.getChangesets().get(myChangesetsTable.getSelectionModel().getMinSelectionIndex());
//      return new ChangesetVersionSpec(fromChangeset.getCset());
//    }
//    else {
//      return null;
//    }
//  }

//  @Nullable
//  public VersionSpecBase getToVersion() {
//    ChangesType changesType = (ChangesType)changesTypeCombo.getSelectedItem();
//    if (changesType == ChangesType.SELECTED) {
//      final Changeset toChangeset =
//        myChangesetsTableModel.getChangesets().get(myChangesetsTable.getSelectionModel().getMaxSelectionIndex());
//      return new ChangesetVersionSpec(toChangeset.getCset());
//    }
//    else {
//      return mySelectRevisionForm.getVersionSpec();
//    }
//  }

    public void addListener(Listener listener) {
        myEventDispatcher.addListener(listener);
    }

    public void removeListener(Listener listener) {
        myEventDispatcher.removeListener(listener);
    }

    private void fireStateChanged() {
        myEventDispatcher.getMulticaster().stateChanged(canFinish());
    }

    private boolean canFinish() {
//        ChangesType changesType = (ChangesType) changesTypeCombo.getSelectedItem();
//        if (changesType == ChangesType.SELECTED) {
//            if (myChangesetsTable.getSelectedRowCount() == 0) {
//                return false;
//            }
//        }
//
//        if (targetCombo.getSelectedIndex() == -1) {
//            return false;
//        }

        return true;
    }

    private void updateOnSourceChange() {
        try {
            //TODO we should provide progress and cancelability here
            List<String> targetBranches = branchListProvider.getBranches(getSourcePath());

            //TODO we may need to filter the branches somehow for the user instead of returning ALL related branches
            ((DefaultComboBoxModel) targetCombo.getModel()).removeAllElements();
            for (final String targetBranch : targetBranches) {
                ((DefaultComboBoxModel) targetCombo.getModel()).addElement(targetBranch);
            }
            //mySelectRevisionForm.init(project, myWorkspace, sourceText.getText(), mySourceIsDirectory);
            fireStateChanged();

        } catch (Throwable t) {
            Messages.showErrorDialog(project, t.getMessage(), dialogTitle);
        }
    }

    public void close() {
        sourceText.getTextField().removeFocusListener(mySourceFieldFocusListener);
    }

    public JComponent getPreferredFocusedComponent() {
        return sourceText.getChildComponent();
    }

}
